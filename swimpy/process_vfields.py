'''
Functions for processing velocity fields generated by PIV analysis

developed by William Gilpin, 2015--present
https://github.com/williamgilpin/swimpy

DEV: Add special methods for writing and opening .pkl functions, a
ll functions should take data structure representing an opened .pkl

'''

from numpy import *

import glob
import warnings

import scipy.ndimage
from scipy.ndimage.filters import convolve1d
from scipy.signal import medfilt
from scipy.spatial.distance import pdist, squareform
from skimage.segmentation import find_boundaries
from skimage.measure import label
from skimage.morphology import skeletonize

from scipy.misc import imresize


def smooth_vector_field(directory_path, num_to_average):
    '''
    This code is optimized for situations in which the contents
    of the entire directory can be stored in RAM.
    
    directory_path : str
        A string with the path to a directory containing .pkl files corresponding to 
        vector fields. 
        
    num_to_average : int
        The number of frames to average together
        
    Outputs
    -------
    
    new_alldata : array
        An array containing all of the data smoothed
    '''
    data_files = glob.glob(directory_path+'/*.pkl')

    array_shape = load(data_files[0]).shape
    alldata = zeros(array_shape+(len(data_files),))

    for ind, filename in enumerate(data_files):
        vfield = load(filename)
        alldata[:,:,:,ind] = vfield

    new_alldata = convolve1d(alldata, ones((num_to_average,))/num_to_average,\
                             axis=-1, mode='reflect')
    
    return new_alldata

def find_jacobian(x, y, u, v, order=2):
    '''
    Given a 2D vector field, calculate the jacobian matrix of partial derivative.
    The second coordinate gives x, the first coordinate gives y
    
    x,y,u,v

    order : int
        The order of the central finite difference operator.
        
    '''
    
    dy = abs( median(diff(y, n=1, axis=0)))
    dx = abs( median(diff(x, n=1, axis=1)))
    
    dvy_dy = diff(v, n=order, axis=0)/dy
    dvx_dx = diff(u, n=order, axis=1)/dx
    dvx_dy = diff(u, n=order, axis=0)/dy
    dvy_dx = diff(v, n=order, axis=1)/dx
    
    dvy_dx = dvy_dx[:-order,:]
    dvx_dy = dvx_dy[:,:-order]
    dvx_dx = dvx_dx[:-order,:]
    dvy_dy = dvy_dy[:,:-order]

    
    jacob = [[dvx_dx, dvx_dy],[dvy_dx, dvy_dy]]
    
    return jacob



def find_vorticity(x, y, u, v, order=2):
    '''
    Given a 2D vector field, calculate the curl and this vorticity
    
    By default, vorticity is calculated using the second-order finite difference
    
    order : int
        The order of the central finite difference operator.
    '''
    
    jacob = find_jacobian(x, y, u, v, order=order)
    
    curl_val = jacob[1][0] - jacob[0][1]
    
    return curl_val

 
def anisodiff(img,niter=1,kappa=50,gamma=0.1,step=(1.,1.),option=1,ploton=False):
        """
        Anisotropic diffusion.
 
        Usage:
        imgout = anisodiff(im, niter, kappa, gamma, option)
 
        Arguments:
                img    - input image
                niter  - number of iterations
                kappa  - conduction coefficient 20-100 ?
                gamma  - max value of .25 for stability
                step   - tuple, the distance between adjacent pixels in (y,x)
                option - 1 Perona Malik diffusion equation No 1
                         2 Perona Malik diffusion equation No 2
                ploton - if True, the image will be plotted on every iteration
 
        Returns:
                imgout   - diffused image.
 
        kappa controls conduction as a function of gradient.  If kappa is low
        small intensity gradients are able to block conduction and hence diffusion
        across step edges.  A large value reduces the influence of intensity
        gradients on conduction.
 
        gamma controls speed of diffusion (you usually want it at a maximum of
        0.25)
 
        step is used to scale the gradients in case the spacing between adjacent
        pixels differs in the x and y axes
 
        Diffusion equation 1 favours high contrast edges over low contrast ones.
        Diffusion equation 2 favours wide regions over smaller ones.
 
        Reference:
        P. Perona and J. Malik.
        Scale-space and edge detection using ansotropic diffusion.
        IEEE Transactions on Pattern Analysis and Machine Intelligence,
        12(7):629-639, July 1990.
 
        Original MATLAB code by Peter Kovesi  
        School of Computer Science & Software Engineering
        The University of Western Australia
        pk @ csse uwa edu au
        <http://www.csse.uwa.edu.au>
 
        Translated to Python and optimised by Alistair Muldal
        Department of Pharmacology
        University of Oxford
        <alistair.muldal@pharm.ox.ac.uk>
 
        June 2000  original version.      
        March 2002 corrected diffusion eqn No 2.
        July 2012 translated to Python
        """
 
        # ...you could always diffuse each color channel independently if you
        # really want
        if img.ndim == 3:
                warnings.warn("Only grayscale images allowed, converting to 2D matrix")
                img = img.mean(2)
 
        # initialize output array
        img = img.astype('float32')
        imgout = img.copy()
 
        # initialize some internal variables
        deltaS = zeros_like(imgout)
        deltaE = deltaS.copy()
        NS = deltaS.copy()
        EW = deltaS.copy()
        gS = ones_like(imgout)
        gE = gS.copy()
 
        # create the plot figure, if requested
        if ploton:
                import pylab as pl
                from time import sleep
 
                fig = pl.figure(figsize=(20,5.5),num="Anisotropic diffusion")
                ax1,ax2 = fig.add_subplot(1,2,1),fig.add_subplot(1,2,2)
 
                ax1.imshow(img,interpolation='nearest')
                ih = ax2.imshow(imgout,interpolation='nearest',animated=True)
                ax1.set_title("Original image")
                ax2.set_title("Iteration 0")
 
                fig.canvas.draw()
 
        for ii in range(niter):
 
                # calculate the diffs
                deltaS[:-1,: ] = diff(imgout,axis=0)
                deltaE[: ,:-1] = diff(imgout,axis=1)
 
                # conduction gradients (only need to compute one per dim!)
                if option == 1:
                        gS = exp(-(deltaS/kappa)**2.)/step[0]
                        gE = exp(-(deltaE/kappa)**2.)/step[1]
                elif option == 2:
                        gS = 1./(1.+(deltaS/kappa)**2.)/step[0]
                        gE = 1./(1.+(deltaE/kappa)**2.)/step[1]
 
                # update matrices
                E = gE*deltaE
                S = gS*deltaS
 
                # subtract a copy that has been shifted 'North/West' by one
                # pixel. don't as questions. just do it. trust me.
                NS[:] = S
                EW[:] = E
                NS[1:,:] -= S[:-1,:]
                EW[:,1:] -= E[:,:-1]
 
                # update the image
                imgout += gamma*(NS+EW)
 
                if ploton:
                        iterstring = "Iteration %i" %(ii+1)
                        ih.set_data(imgout)
                        ax2.set_title(iterstring)
                        fig.canvas.draw()
                        # sleep(0.01)
 
        return imgout

def unpack_component_list(val_list, shape=''):
    '''Given a 1xN list of vector field components, 
        unpack it to a square array. Defaults to assuming
        a square array
        
    val_list : list
        A 1 dimensional list of components or coordinates 
        
    shape : 2-tuple or list
        The dimensions of the vector field
    '''
    
    if not shape:
        sqlen = sqrt(1.0*len(val_list))
        #shp = sqlen, sqlen
        shp = int(sqlen), int(sqlen)
        if shp[0] % 1 != 0:
            warnings.warn("Your vector field is not square, please specify a shape")
    else:
        shp = shape
    
    out = val_list.reshape(*shp)
    return out

def make_component_list(val_list):
    '''wrap a vector field into a list of coordinates.
    this function is just a wrapper for ravel
    '''
    return ravel(val_list)

def rotate_vector(vec, angle, deg=True):
    '''Rotate a two-dimensional vector (or list of vectors) in the plane
    vec : 2-list, 2-array, or 2-tuple
    
    angle : float
        The rotation angle
        
    deg : bool
        Whether the input angle is given in degrees
    '''
    
    if deg:
        ang = radians(angle)
    else:
        ang = angle
    
    if len(vec.shape)==1:
        out = (vec[0]*cos(ang)-vec[1]*sin(ang)), (vec[0]*sin(ang)+vec[1]*cos(ang))
    else:
        out = list()
        for row in vec:
            rot_row = (row[0]*cos(ang)-row[1]*sin(ang)), (row[0]*sin(ang)+row[1]*cos(ang))
            out.append(rot_row)
        out = array(out) 
    return out

def median_dataset(dataset,**kwargs):
    '''
    Take the spatial median of a list of vector coordinates
    This function accepts any keyword arguments of the underlying
    scipy function medfilt

    kernel_size : scalar or tuple
        The size of the region to take the median over

    '''
    eig1_sq = [unpack_component_list(dataset[:,0]), unpack_component_list(dataset[:,1])]
    eig1_sq_filt = [medfilt(thing,**kwargs) for thing in eig1_sq]
    eig1_sq_filt_list = [make_component_list(thing) for thing in eig1_sq_filt]
    
    return (array(eig1_sq_filt_list).T)




    
# def contourprofile_pivdata(data_dir, line_coords, slice_indices='', averaging_method='median', show_profile=False, rotate_comps=True):
#     '''
#     Extract the countour profile from a collection of PIV velocity fields, 
#     averaged across several frames
    
#     Because subpixel interpolation is being used, it's best to display these
#     as lines not points
    
#     data_dir : str
#         The path to the directory containing PIV .txt files
    
#     line_coords : 2-list of arrays
#         A list of the form [x_coordinates, y_coordinates] specifying
#         a contour. Upsampling this contour must be performed beforehand.
    
#     slice indices : 3-tuple
#         The first, last, and increment slice
    
#     averaging_method : str
#         The type of averaging method to use:
#         median
#         mean
    
#     show_profile : bool
#         Make a drawing showing the values field from one frame with
#         the line trace overlaid
        
#     rotate_comps : bool
#         Project the velocity traces into components parallel and 
#         perpendicular to the line trace (parallel, perp)
        
#     Returns
#     -------
    
#     (outui, outvi) : (list, list) 
#         A list of interpolated normal (ui) and tangential (vi) velocity
#         components
#     '''
    
#     subpixel_factor = 2.0 # factor to interpolate beyond the input pixel density
    
#     alldata = glob.glob(data_dir+'/*.txt')
    
#     if not slice_indices:
#         start,stop,skip = (0,-1,1)
#     else:
#         start, stop, skip = slice_indices
#     alldata = alldata[start:stop][::skip]
        
#     [x, y] = line_coords
    
#     all_ui, all_vi = list(), list()
#     for dataset in alldata:
#         (u, v) = import_pivdata(dataset,indices=(2,3))
#         u = reshape_pivdata(u)
#         v = reshape_pivdata(v)
#         all_ui.append( scipy.ndimage.map_coordinates(u, vstack((x,y))) )
#         all_vi.append( scipy.ndimage.map_coordinates(v, vstack((x,y))) )
    
#     outui, outvi = median(array(all_ui),axis=0), mean(array(all_vi),axis=0)
    
#     # DO THIS INDIVIDUALLY FOR EACH PART OF CONTOUR.
#     if rotate_comps:
        
#         all_vector_data = array(list(zip(outui, outvi)))
        
#         for ind,_ in enumerate(zip(x,y)):
            
#             #if ind==len(x):
    
#             if ind == len(x):
#                 rotang = pi-arctan2(x[0]-x[ind], y[0]-y[ind])
#             else:
#                 rotang = pi-arctan2(x[ind+1]-x[ind], y[ind+1]-y[ind])
            
#             all_vector_data[ind]
            
            
#             all_rots = rotate_vector(array(list(zip(outui, outvi))), rotang, deg=False)
#             outui, outvi = all_rots[:,0], all_rots[:,1]

#     if show_profile:
#         figure()
#         #imshow(u,origin='lower')
#         imshow(log(sqrt(u**2 + v**2)),origin='lower')
#         hold(True)
#         plot(x,y,'.')
        
#         plot(linspace(x0,x1,5),linspace(y0,y1,5),'.')
        
#         #org_vec = rotate_vector(array([x0,y0]), -rotang, deg=False)
#         #end_vec = rotate_vector(array([x1,y1]), -rotang, deg=False)
#         #plot([org_vec[0],end_vec[0]], [org_vec[1],end_vec[1]])
    
    
#     return (outui, outvi)




